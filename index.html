<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Astronomical Instruments Calculator</title>
    <meta name="description" content="Generate dimensions and 3D visualizations for traditional Indian astronomical instruments (Yantras) based on geographic location">
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- React and ReactDOM CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel Standalone for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        
        #root.dark {
            min-height: 100vh;
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 50%, #312e81 100%);
        }
        
        #root.light {
            min-height: 100vh;
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 50%, #fcd34d 100%);
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
        }
        
        .dark ::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
        }
        
        .light ::-webkit-scrollbar-track {
            background: rgba(254, 243, 199, 0.5);
        }
        
        .dark ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #8b5cf6 0%, #6366f1 100%);
            border-radius: 6px;
        }
        
        .light ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #f59e0b 0%, #d97706 100%);
            border-radius: 6px;
        }
        
        .dark ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #a78bfa 0%, #818cf8 100%);
        }
        
        .light ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #fbbf24 0%, #f59e0b 100%);
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes shimmer {
            0% { background-position: -1000px 0; }
            100% { background-position: 1000px 0; }
        }
        
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        
        .dark .glass-card {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(139, 92, 246, 0.3);
        }
        
        .light .glass-card {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(245, 158, 11, 0.3);
        }
        
        .dark .gradient-text {
            background: linear-gradient(135deg, #a78bfa 0%, #ec4899 50%, #818cf8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .light .gradient-text {
            background: linear-gradient(135deg, #f59e0b 0%, #dc2626 50%, #ea580c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
    </style>
</head>
<body>
    <!-- Root element where React app will mount -->
    <div id="root"></div>

    <!-- Main Application Script -->
    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // Lucide Icon Components
        const Calculator = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <rect x="4" y="2" width="16" height="20" rx="2"/>
                <line x1="8" y1="6" x2="16" y2="6"/>
                <line x1="16" y1="10" x2="16" y2="10"/>
                <line x1="8" y1="10" x2="8" y2="10"/>
                <line x1="12" y1="10" x2="12" y2="10"/>
                <line x1="8" y1="14" x2="8" y2="18"/>
                <line x1="12" y1="14" x2="12" y2="14"/>
                <line x1="12" y1="18" x2="12" y2="18"/>
                <line x1="16" y1="14" x2="16" y2="18"/>
            </svg>
        );

        const MapPin = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
                <circle cx="12" cy="10" r="3"/>
            </svg>
        );

        const Ruler = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.4 2.4 0 0 1 0-3.4l2.6-2.6a2.4 2.4 0 0 1 3.4 0z"/>
                <path d="m14.5 12.5 2-2"/>
                <path d="m11.5 9.5 2-2"/>
                <path d="m8.5 6.5 2-2"/>
                <path d="m17.5 15.5 2-2"/>
            </svg>
        );

        const Box = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
                <polyline points="3.27 6.96 12 12.01 20.73 6.96"/>
                <line x1="12" y1="22.08" x2="12" y2="12"/>
            </svg>
        );

        const Sun = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <circle cx="12" cy="12" r="4"/>
                <path d="M12 2v2"/>
                <path d="M12 20v2"/>
                <path d="m4.93 4.93 1.41 1.41"/>
                <path d="m17.66 17.66 1.41 1.41"/>
                <path d="M2 12h2"/>
                <path d="M20 12h2"/>
                <path d="m6.34 17.66-1.41 1.41"/>
                <path d="m19.07 4.93-1.41 1.41"/>
            </svg>
        );

        const Moon = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/>
            </svg>
        );

        // Yantra Calculator Module
        class YantraCalculator {
          constructor(latitude, longitude, baseSize = 10) {
            this.latitude = latitude;
            this.longitude = longitude;
            this.baseSize = baseSize;
            this.phi = latitude * Math.PI / 180;
          }

          calculateSamratYantra() {
            const gnomonHeight = this.baseSize;
            const gnomonBase = gnomonHeight / Math.tan(this.phi);
            const hypotenuse = Math.sqrt(gnomonHeight * gnomonHeight + gnomonBase * gnomonBase);
            const dialRadius = gnomonBase * 1.5;
            
            return {
              name: "Samrat Yantra",
              type: "sundial",
              dimensions: {
                gnomonHeight,
                gnomonBase,
                hypotenuse,
                dialRadius,
                gnomonAngle: this.latitude,
                quadrantArcLength: dialRadius * Math.PI / 2
              },
              description: "Giant equinoctial sundial with gnomon aligned to Earth's axis",
              detailedInfo: {
                purpose: "The Samrat Yantra (Supreme Instrument) is the largest and most accurate sundial, designed to measure local time with precision up to 2 seconds.",
                construction: "Features a massive triangular gnomon (pointer) whose hypotenuse is parallel to Earth's axis. The gnomon casts shadows on quadrant scales marked with hours, minutes, and seconds.",
                usage: "As the sun moves across the sky, the gnomon's shadow moves along the curved quadrants. Time is read where the shadow's edge intersects the scale markings.",
                accuracy: "Can measure time to within 2 seconds accuracy. The large size minimizes errors from shadow edge diffusion.",
                historicalContext: "Built by Maharaja Jai Singh II in the 18th century. The Jaipur Samrat Yantra stands 27 meters tall and is a UNESCO World Heritage site."
              }
            };
          }

          calculateRamaYantra() {
            const cylinderRadius = this.baseSize;
            const cylinderHeight = cylinderRadius * 0.3;
            const pillarHeight = cylinderHeight * 1.5;
            
            return {
              name: "Rama Yantra",
              type: "altitude_azimuth",
              dimensions: {
                cylinderRadius,
                cylinderHeight,
                pillarHeight,
                sectorAngle: 90,
                numberOfSectors: 4
              },
              description: "Used to measure altitude and azimuth of celestial objects",
              detailedInfo: {
                purpose: "The Rama Yantra measures the altitude (elevation angle) and azimuth (horizontal angle) of celestial bodies like stars and planets.",
                construction: "Consists of two identical cylindrical structures with open tops, divided into sectors. A vertical pillar at the center casts shadows on graduated scales.",
                usage: "Observers use the shadow cast by the central pillar to determine the altitude and azimuth coordinates of celestial objects. The complementary pair allows measurements across the full sky.",
                accuracy: "Provides accurate measurements of celestial coordinates, essential for astronomical observations and astrological calculations.",
                historicalContext: "Named after Lord Rama, this instrument demonstrates advanced understanding of spherical astronomy in 18th century India."
              }
            };
          }

          calculateChakraYantra() {
            const outerRadius = this.baseSize * 0.8;
            const innerRadius = outerRadius * 0.15;
            const thickness = outerRadius * 0.05;
            
            return {
              name: "Chakra Yantra",
              type: "angular_measurement",
              dimensions: {
                outerRadius,
                innerRadius,
                thickness,
                graduations: 360,
                crossBarLength: outerRadius * 2,
                poleHeight: outerRadius * 1.5
              },
              description: "Metal ring instrument for measuring angular positions",
              detailedInfo: {
                purpose: "The Chakra Yantra (Wheel Instrument) is used to measure the declination and hour angle of celestial objects, helping determine their position in the sky.",
                construction: "Features a large metal ring graduated in degrees, mounted on a pole. A crossbar with sighting holes allows precise angular measurements.",
                usage: "Astronomers align the sighting mechanism with a celestial object and read its angular position from the graduated ring. Can measure both horizontal and vertical angles.",
                accuracy: "The 360-degree graduation allows precise angular measurements essential for tracking planetary motions and stellar positions.",
                historicalContext: "Represents the ancient Indian tradition of precision instrument making, combining metalworking skills with astronomical knowledge."
              }
            };
          }

          calculateJaiPrakashYantra() {
            const hemisphereRadius = this.baseSize;
            const rimWidth = hemisphereRadius * 0.1;
            const crossWireSpacing = hemisphereRadius * 0.2;
            
            return {
              name: "Jai Prakash Yantra",
              type: "celestial_coordinates",
              dimensions: {
                hemisphereRadius,
                rimWidth,
                crossWireSpacing,
                numberOfMarbleSlabs: 2,
                depthOfHemisphere: hemisphereRadius
              },
              description: "Hemispherical sundial showing celestial coordinates",
              detailedInfo: {
                purpose: "The Jai Prakash Yantra (Light of Jai Singh) is an inverted celestial sphere used to determine the position of the sun and other celestial bodies at any time.",
                construction: "Consists of two complementary hemispherical bowls sunk into the ground, with marble slabs forming the inverse of a celestial sphere. Crosswires stretched across the bowls serve as reference points.",
                usage: "The sun's position is determined by observing where its image falls on the graduated marble surface. The complementary bowls ensure continuous observation throughout the day.",
                accuracy: "Provides highly accurate measurements of celestial coordinates including right ascension, declination, and zenith distance.",
                historicalContext: "Named after its creator Maharaja Jai Singh II, this instrument represents the pinnacle of observational astronomy in 18th century India. Its innovative inverted design solved many practical observation challenges."
              }
            };
          }

          calculateDigamsaYantra() {
            const baseRadius = this.baseSize;
            const pillarHeight = baseRadius * 2;
            const circleRadius = baseRadius * 0.9;
            
            return {
              name: "Digamsa Yantra",
              type: "azimuth",
              dimensions: {
                baseRadius,
                pillarHeight,
                circleRadius,
                compassDivisions: 360,
                sightingBarLength: circleRadius * 2
              },
              description: "Used to measure azimuth angles of celestial bodies",
              detailedInfo: {
                purpose: "The Digamsa Yantra (Azimuth Instrument) is specifically designed to measure the azimuth angle - the horizontal direction of celestial objects relative to north.",
                construction: "Features a circular base graduated in 360 degrees like a compass, with a tall central pillar and a rotating sighting bar for precise directional measurements.",
                usage: "Observers rotate the sighting bar to align with a celestial object and read its azimuth angle from the graduated circular base. Essential for determining cardinal directions and object positions.",
                accuracy: "The 360-degree graduation provides precise azimuth measurements crucial for navigation, timekeeping, and astronomical calculations.",
                historicalContext: "This instrument reflects the importance of directional measurements in Indian astronomy, particularly for determining prayer times and auspicious directions in Vedic traditions."
              }
            };
          }

          calculateAllYantras() {
            return [
              this.calculateSamratYantra(),
              this.calculateRamaYantra(),
              this.calculateChakraYantra(),
              this.calculateJaiPrakashYantra(),
              this.calculateDigamsaYantra()
            ];
          }
        }

        // 2D Diagram Generator Component
        const DiagramGenerator = ({ yantra, theme }) => {
          const canvasRef = useRef(null);

          useEffect(() => {
            if (!canvasRef.current || !yantra) return;
            
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const scale = 20;
            
            ctx.clearRect(0, 0, width, height);
            
            // Gradient background
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            if (theme === 'dark') {
              gradient.addColorStop(0, '#0f172a');
              gradient.addColorStop(1, '#1e1b4b');
              ctx.strokeStyle = '#a78bfa';
              ctx.fillStyle = '#8b5cf6';
              ctx.shadowColor = '#8b5cf6';
            } else {
              gradient.addColorStop(0, '#fef3c7');
              gradient.addColorStop(1, '#fde68a');
              ctx.strokeStyle = '#f59e0b';
              ctx.fillStyle = '#ea580c';
              ctx.shadowColor = '#f59e0b';
            }
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            ctx.fillStyle = theme === 'dark' ? '#8b5cf6' : '#ea580c';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10;
            ctx.font = '12px monospace';
            
            const centerX = width / 2;
            const centerY = height / 2;
            
            if (yantra.type === 'sundial') {
              const h = yantra.dimensions.gnomonHeight * scale;
              const b = yantra.dimensions.gnomonBase * scale;
              
              ctx.beginPath();
              ctx.moveTo(centerX - b/2, centerY + 50);
              ctx.lineTo(centerX - b/2, centerY + 50 - h);
              ctx.lineTo(centerX + b/2, centerY + 50);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
              
              ctx.beginPath();
              ctx.arc(centerX - b/2, centerY + 50, yantra.dimensions.dialRadius * scale, 0, Math.PI, true);
              ctx.stroke();
              
              ctx.shadowBlur = 0;
              ctx.fillStyle = '#fbbf24';
              ctx.font = 'bold 13px monospace';
              ctx.fillText(`H: ${yantra.dimensions.gnomonHeight.toFixed(2)}m`, centerX - b/2 - 60, centerY + 20);
              ctx.fillText(`B: ${yantra.dimensions.gnomonBase.toFixed(2)}m`, centerX - 30, centerY + 70);
              ctx.fillText(`Angle: ${yantra.dimensions.gnomonAngle.toFixed(1)}°`, centerX + b/2 + 10, centerY + 30);
              
            } else if (yantra.type === 'altitude_azimuth') {
              const r = yantra.dimensions.cylinderRadius * scale;
              
              ctx.beginPath();
              ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
              ctx.stroke();
              
              for (let i = 0; i < 4; i++) {
                const angle = i * Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + r * Math.cos(angle), centerY + r * Math.sin(angle));
                ctx.stroke();
              }
              
              ctx.shadowBlur = 0;
              ctx.fillStyle = '#fbbf24';
              ctx.font = 'bold 13px monospace';
              ctx.fillText(`R: ${yantra.dimensions.cylinderRadius.toFixed(2)}m`, centerX + r + 10, centerY);
              ctx.fillText(`4 Sectors`, centerX - 30, centerY - r - 10);
              
            } else if (yantra.type === 'angular_measurement') {
              const outer = yantra.dimensions.outerRadius * scale;
              const inner = yantra.dimensions.innerRadius * scale;
              
              ctx.beginPath();
              ctx.arc(centerX, centerY, outer, 0, Math.PI * 2);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.arc(centerX, centerY, inner, 0, Math.PI * 2);
              ctx.stroke();
              
              ctx.beginPath();
              ctx.moveTo(centerX - outer, centerY);
              ctx.lineTo(centerX + outer, centerY);
              ctx.stroke();
              
              ctx.shadowBlur = 0;
              ctx.fillStyle = '#fbbf24';
              ctx.font = 'bold 13px monospace';
              ctx.fillText(`R: ${yantra.dimensions.outerRadius.toFixed(2)}m`, centerX + outer + 10, centerY);
              
            } else if (yantra.type === 'celestial_coordinates') {
              const r = yantra.dimensions.hemisphereRadius * scale;
              
              ctx.beginPath();
              ctx.arc(centerX, centerY + 50, r, Math.PI, 0, true);
              ctx.stroke();
              
              ctx.strokeStyle = '#f59e0b';
              ctx.lineWidth = 4;
              ctx.shadowBlur = 15;
              ctx.shadowColor = '#f59e0b';
              ctx.beginPath();
              ctx.arc(centerX, centerY + 50, r, Math.PI, 0, true);
              ctx.stroke();
              ctx.lineWidth = 3;
              ctx.strokeStyle = '#a78bfa';
              ctx.shadowBlur = 10;
              ctx.shadowColor = '#8b5cf6';
              
              ctx.shadowBlur = 0;
              ctx.fillStyle = '#fbbf24';
              ctx.font = 'bold 13px monospace';
              ctx.fillText(`Hemisphere R: ${yantra.dimensions.hemisphereRadius.toFixed(2)}m`, centerX - 80, centerY + 80);
              
            } else if (yantra.type === 'azimuth') {
              const r = yantra.dimensions.circleRadius * scale;
              const h = yantra.dimensions.pillarHeight * scale;
              
              ctx.beginPath();
              ctx.arc(centerX, centerY + 50, r, 0, Math.PI * 2);
              ctx.stroke();
              
              ctx.fillRect(centerX - 5, centerY + 50 - h, 10, h);
              
              ctx.strokeStyle = '#fbbf24';
              ctx.beginPath();
              ctx.moveTo(centerX - r, centerY + 50 - h);
              ctx.lineTo(centerX + r, centerY + 50 - h);
              ctx.stroke();
              ctx.strokeStyle = '#a78bfa';
              
              ctx.shadowBlur = 0;
              ctx.fillStyle = '#fbbf24';
              ctx.font = 'bold 13px monospace';
              ctx.fillText(`H: ${yantra.dimensions.pillarHeight.toFixed(2)}m`, centerX + 20, centerY + 20);
            }
            
          }, [yantra, theme]);

          return (
            <canvas 
              ref={canvasRef} 
              width={400} 
              height={300}
              className={`border-2 rounded-lg shadow-lg ${
                theme === 'dark' 
                  ? 'border-purple-500 shadow-purple-500/50' 
                  : 'border-orange-500 shadow-orange-500/50'
              }`}
            />
          );
        };

        // 3D Model Renderer Component
        const Model3D = ({ yantra, theme }) => {
          const mountRef = useRef(null);
          const sceneRef = useRef(null);
          const rendererRef = useRef(null);
          const cameraRef = useRef(null);
          const mouseRef = useRef({ isDown: false, x: 0, y: 0 });

          useEffect(() => {
            if (!mountRef.current || !yantra) return;

            const scene = new THREE.Scene();
            if (theme === 'dark') {
              scene.background = new THREE.Color(0x0a0a1a);
              scene.fog = new THREE.Fog(0x0a0a1a, 30, 100);
            } else {
              scene.background = new THREE.Color(0xfef3c7);
              scene.fog = new THREE.Fog(0xfef3c7, 30, 100);
            }
            sceneRef.current = scene;

            const camera = new THREE.PerspectiveCamera(50, 400 / 300, 0.1, 1000);
            camera.position.set(20, 20, 20);
            camera.lookAt(0, 0, 0);
            cameraRef.current = camera;

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(400, 300);
            mountRef.current.appendChild(renderer.domElement);
            rendererRef.current = renderer;

            if (theme === 'dark') {
              const ambientLight = new THREE.AmbientLight(0x8b5cf6, 0.4);
              scene.add(ambientLight);
              
              const directionalLight1 = new THREE.DirectionalLight(0xa78bfa, 1.2);
              directionalLight1.position.set(10, 15, 10);
              directionalLight1.castShadow = true;
              scene.add(directionalLight1);
              
              const directionalLight2 = new THREE.DirectionalLight(0x6366f1, 0.8);
              directionalLight2.position.set(-10, 10, -10);
              scene.add(directionalLight2);
              
              const pointLight = new THREE.PointLight(0xfbbf24, 1, 50);
              pointLight.position.set(0, 10, 0);
              scene.add(pointLight);

              const gridHelper = new THREE.GridHelper(30, 30, 0x8b5cf6, 0x312e81);
              scene.add(gridHelper);
            } else {
              const ambientLight = new THREE.AmbientLight(0xf59e0b, 0.5);
              scene.add(ambientLight);
              
              const directionalLight1 = new THREE.DirectionalLight(0xfbbf24, 1.5);
              directionalLight1.position.set(10, 15, 10);
              directionalLight1.castShadow = true;
              scene.add(directionalLight1);
              
              const directionalLight2 = new THREE.DirectionalLight(0xea580c, 1.0);
              directionalLight2.position.set(-10, 10, -10);
              scene.add(directionalLight2);
              
              const pointLight = new THREE.PointLight(0xdc2626, 1, 50);
              pointLight.position.set(0, 10, 0);
              scene.add(pointLight);

              const gridHelper = new THREE.GridHelper(30, 30, 0xf59e0b, 0xfde68a);
              scene.add(gridHelper);
            }
            
            // Add axes helper for better orientation
            const axesHelper = new THREE.AxesHelper(15);
            scene.add(axesHelper);

            // Build 3D model
            if (yantra.type === 'sundial') {
              const h = yantra.dimensions.gnomonHeight;
              const b = yantra.dimensions.gnomonBase;
              
              const shape = new THREE.Shape();
              shape.moveTo(-b/2, 0);
              shape.lineTo(-b/2, h);
              shape.lineTo(b/2, 0);
              shape.lineTo(-b/2, 0);
              
              const extrudeSettings = { depth: 0.5, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1 };
              const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
              const material = new THREE.MeshStandardMaterial({ 
                color: 0x8b5cf6,
                metalness: 0.6,
                roughness: 0.3,
                emissive: 0x6366f1,
                emissiveIntensity: 0.2
              });
              const gnomon = new THREE.Mesh(geometry, material);
              gnomon.rotation.x = -Math.PI / 2;
              scene.add(gnomon);
              
              const dialGeometry = new THREE.TorusGeometry(yantra.dimensions.dialRadius, 0.2, 16, 32, Math.PI);
              const dialMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xfbbf24,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xf59e0b,
                emissiveIntensity: 0.3
              });
              const dial = new THREE.Mesh(dialGeometry, dialMaterial);
              dial.rotation.x = Math.PI / 2;
              dial.position.set(-b/2, 0, 0);
              scene.add(dial);
              
            } else if (yantra.type === 'altitude_azimuth') {
              const r = yantra.dimensions.cylinderRadius;
              const h = yantra.dimensions.cylinderHeight;
              
              const geometry = new THREE.CylinderGeometry(r, r, h, 32, 1, true);
              const material = new THREE.MeshStandardMaterial({ 
                color: 0x8b5cf6, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6,
                metalness: 0.5,
                roughness: 0.3,
                emissive: 0x6366f1,
                emissiveIntensity: 0.2
              });
              const cylinder = new THREE.Mesh(geometry, material);
              cylinder.position.y = h / 2;
              scene.add(cylinder);
              
              const pillarGeometry = new THREE.CylinderGeometry(0.3, 0.3, yantra.dimensions.pillarHeight);
              const pillarMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xfbbf24,
                metalness: 0.7,
                roughness: 0.2,
                emissive: 0xf59e0b,
                emissiveIntensity: 0.3
              });
              const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
              pillar.position.y = yantra.dimensions.pillarHeight / 2;
              scene.add(pillar);
              
            } else if (yantra.type === 'angular_measurement') {
              const outer = yantra.dimensions.outerRadius;
              
              const geometry = new THREE.TorusGeometry(outer, 0.3, 16, 64);
              const material = new THREE.MeshStandardMaterial({ 
                color: 0x8b5cf6,
                metalness: 0.7,
                roughness: 0.2,
                emissive: 0x6366f1,
                emissiveIntensity: 0.3
              });
              const ring = new THREE.Mesh(geometry, material);
              ring.rotation.x = Math.PI / 2;
              scene.add(ring);
              
              const barGeometry = new THREE.BoxGeometry(outer * 2, 0.2, 0.2);
              const barMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xfbbf24,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xf59e0b,
                emissiveIntensity: 0.4
              });
              const bar = new THREE.Mesh(barGeometry, barMaterial);
              scene.add(bar);
              
            } else if (yantra.type === 'celestial_coordinates') {
              const r = yantra.dimensions.hemisphereRadius;
              
              const geometry = new THREE.SphereGeometry(r, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
              const material = new THREE.MeshStandardMaterial({ 
                color: 0x8b5cf6,
                side: THREE.DoubleSide,
                metalness: 0.5,
                roughness: 0.3,
                emissive: 0x6366f1,
                emissiveIntensity: 0.2
              });
              const hemisphere = new THREE.Mesh(geometry, material);
              scene.add(hemisphere);
              
              const rimGeometry = new THREE.TorusGeometry(r, 0.2, 16, 64);
              const rimMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xfbbf24,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xf59e0b,
                emissiveIntensity: 0.4
              });
              const rim = new THREE.Mesh(rimGeometry, rimMaterial);
              rim.rotation.x = Math.PI / 2;
              scene.add(rim);
              
            } else if (yantra.type === 'azimuth') {
              const r = yantra.dimensions.circleRadius;
              const h = yantra.dimensions.pillarHeight;
              
              const baseGeometry = new THREE.TorusGeometry(r, 0.2, 16, 64);
              const baseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8b5cf6,
                metalness: 0.7,
                roughness: 0.2,
                emissive: 0x6366f1,
                emissiveIntensity: 0.3
              });
              const base = new THREE.Mesh(baseGeometry, baseMaterial);
              base.rotation.x = Math.PI / 2;
              scene.add(base);
              
              const pillarGeometry = new THREE.CylinderGeometry(0.3, 0.3, h);
              const pillarMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xa78bfa,
                metalness: 0.6,
                roughness: 0.3,
                emissive: 0x8b5cf6,
                emissiveIntensity: 0.3
              });
              const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
              pillar.position.y = h / 2;
              scene.add(pillar);
              
              const barGeometry = new THREE.BoxGeometry(r * 2, 0.2, 0.2);
              const barMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xfbbf24,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xf59e0b,
                emissiveIntensity: 0.4
              });
              const bar = new THREE.Mesh(barGeometry, barMaterial);
              bar.position.y = h;
              scene.add(bar);
            }

            // Mouse controls
            const canvas = renderer.domElement;
            
            const onMouseDown = (e) => {
              mouseRef.current.isDown = true;
              mouseRef.current.x = e.clientX;
              mouseRef.current.y = e.clientY;
            };
            
            const onMouseMove = (e) => {
              if (!mouseRef.current.isDown) return;
              
              const deltaX = e.clientX - mouseRef.current.x;
              const deltaY = e.clientY - mouseRef.current.y;
              
              scene.rotation.y += deltaX * 0.01;
              scene.rotation.x += deltaY * 0.01;
              
              mouseRef.current.x = e.clientX;
              mouseRef.current.y = e.clientY;
            };
            
            const onMouseUp = () => {
              mouseRef.current.isDown = false;
            };
            
            const onWheel = (e) => {
              e.preventDefault();
              const delta = e.deltaY * 0.001;
              camera.position.multiplyScalar(1 + delta);
            };
            
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel);

            let animationId;
            const animate = () => {
              animationId = requestAnimationFrame(animate);
              renderer.render(scene, camera);
            };
            animate();

            return () => {
              cancelAnimationFrame(animationId);
              canvas.removeEventListener('mousedown', onMouseDown);
              canvas.removeEventListener('mousemove', onMouseMove);
              canvas.removeEventListener('mouseup', onMouseUp);
              canvas.removeEventListener('wheel', onWheel);
              if (mountRef.current && renderer.domElement) {
                mountRef.current.removeChild(renderer.domElement);
              }
              renderer.dispose();
            };
          }, [yantra, theme]);

          return <div ref={mountRef} className={`border-2 rounded-lg shadow-lg ${
            theme === 'dark' 
              ? 'border-purple-500 shadow-purple-500/50' 
              : 'border-orange-500 shadow-orange-500/50'
          }`} />;
        };

        // Main App Component
        function YantraApp() {
          const [latitude, setLatitude] = useState(26.9124);
          const [longitude, setLongitude] = useState(75.7873);
          const [baseSize, setBaseSize] = useState(10);
          const [yantras, setYantras] = useState([]);
          const [selectedYantra, setSelectedYantra] = useState(null);
          const [theme, setTheme] = useState('dark');

          useEffect(() => {
            document.getElementById('root').className = theme;
          }, [theme]);

          const toggleTheme = () => {
            setTheme(theme === 'dark' ? 'light' : 'dark');
          };

          const locations = [
            { name: "Jaipur (Jantar Mantar)", lat: 26.9124, lon: 75.7873 },
            { name: "Delhi (Jantar Mantar)", lat: 28.6271, lon: 77.2166 },
            { name: "Ujjain (Dongla)", lat: 23.1765, lon: 75.7885 },
            { name: "Varanasi", lat: 25.3176, lon: 82.9739 },
            { name: "Mathura", lat: 27.4924, lon: 77.6737 }
          ];

          const calculateYantras = () => {
            const calculator = new YantraCalculator(latitude, longitude, baseSize);
            const calculated = calculator.calculateAllYantras();
            setYantras(calculated);
            setSelectedYantra(calculated[0]);
          };

          return (
            <div className={`min-h-screen p-6 ${theme === 'dark' ? 'text-gray-100' : 'text-gray-900'}`}>
              <div className="max-w-7xl mx-auto">
                <div className="mb-8 animate-fade-in flex justify-between items-start">
                  <div>
                    <h1 className="text-5xl font-bold gradient-text mb-3 flex items-center gap-3">
                      <Calculator size={48} className={theme === 'dark' ? 'text-purple-400' : 'text-orange-600'} />
                      Indian Astronomical Instruments Calculator
                    </h1>
                    <p className={`text-xl ml-16 ${theme === 'dark' ? 'text-purple-200' : 'text-orange-800'}`}>Generate dimensions and visualizations for Yantras based on location</p>
                  </div>
                  <button
                    onClick={toggleTheme}
                    className={`p-3 rounded-lg transition-all transform hover:scale-110 ${
                      theme === 'dark' 
                        ? 'bg-purple-600 hover:bg-purple-500 text-yellow-300' 
                        : 'bg-orange-500 hover:bg-orange-400 text-white'
                    } shadow-lg`}
                    title={`Switch to ${theme === 'dark' ? 'light' : 'dark'} mode`}
                  >
                    {theme === 'dark' ? <Sun size={28} /> : <Moon size={28} />}
                  </button>
                </div>

                <div className="glass-card rounded-xl p-6 mb-6 shadow-2xl shadow-purple-500/20 animate-fade-in">
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                    <div>
                      <label className={`block text-sm font-semibold mb-2 ${theme === 'dark' ? 'text-purple-300' : 'text-orange-700'}`}>Latitude (°)</label>
                      <input
                        type="number"
                        step="0.0001"
                        value={latitude}
                        onChange={(e) => setLatitude(parseFloat(e.target.value))}
                        className={`w-full rounded-lg px-4 py-3 border-2 focus:outline-none focus:ring-2 transition ${
                          theme === 'dark'
                            ? 'bg-slate-800/50 border-purple-500/50 text-white focus:border-purple-400 focus:ring-purple-500/50'
                            : 'bg-white border-orange-400/50 text-gray-900 focus:border-orange-500 focus:ring-orange-400/50'
                        }`}
                      />
                    </div>
                    <div>
                      <label className={`block text-sm font-semibold mb-2 ${theme === 'dark' ? 'text-purple-300' : 'text-orange-700'}`}>Longitude (°)</label>
                      <input
                        type="number"
                        step="0.0001"
                        value={longitude}
                        onChange={(e) => setLongitude(parseFloat(e.target.value))}
                        className={`w-full rounded-lg px-4 py-3 border-2 focus:outline-none focus:ring-2 transition ${
                          theme === 'dark'
                            ? 'bg-slate-800/50 border-purple-500/50 text-white focus:border-purple-400 focus:ring-purple-500/50'
                            : 'bg-white border-orange-400/50 text-gray-900 focus:border-orange-500 focus:ring-orange-400/50'
                        }`}
                      />
                    </div>
                    <div>
                      <label className={`block text-sm font-semibold mb-2 ${theme === 'dark' ? 'text-purple-300' : 'text-orange-700'}`}>Base Size (m)</label>
                      <input
                        type="number"
                        step="1"
                        value={baseSize}
                        onChange={(e) => setBaseSize(parseFloat(e.target.value))}
                        className={`w-full rounded-lg px-4 py-3 border-2 focus:outline-none focus:ring-2 transition ${
                          theme === 'dark'
                            ? 'bg-slate-800/50 border-purple-500/50 text-white focus:border-purple-400 focus:ring-purple-500/50'
                            : 'bg-white border-orange-400/50 text-gray-900 focus:border-orange-500 focus:ring-orange-400/50'
                        }`}
                      />
                    </div>
                  </div>

                  <div className="mb-6">
                    <label className={`block text-sm font-semibold mb-3 ${theme === 'dark' ? 'text-purple-300' : 'text-orange-700'}`}>Quick Select Location:</label>
                    <div className="flex flex-wrap gap-3">
                      {locations.map((loc) => (
                        <button
                          key={loc.name}
                          onClick={() => {
                            setLatitude(loc.lat);
                            setLongitude(loc.lon);
                          }}
                          className={`rounded-lg px-4 py-2 text-sm font-medium flex items-center gap-2 transition-all transform hover:scale-105 shadow-lg border-2 ${
                            theme === 'dark'
                              ? 'bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-500 hover:to-indigo-500 border-purple-400/50 hover:shadow-purple-500/50 text-white'
                              : 'bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-400 hover:to-red-400 border-orange-400/50 hover:shadow-orange-500/50 text-white'
                          }`}
                        >
                          <MapPin size={16} />
                          {loc.name}
                        </button>
                      ))}
                    </div>
                  </div>

                  <button
                    onClick={calculateYantras}
                    className={`px-8 py-3 rounded-lg font-bold text-lg transition-all transform hover:scale-105 shadow-xl text-white ${
                      theme === 'dark'
                        ? 'bg-gradient-to-r from-pink-500 via-purple-500 to-indigo-500 hover:from-pink-600 hover:via-purple-600 hover:to-indigo-600 hover:shadow-pink-500/50'
                        : 'bg-gradient-to-r from-orange-500 via-red-500 to-pink-500 hover:from-orange-600 hover:via-red-600 hover:to-pink-600 hover:shadow-orange-500/50'
                    }`}
                  >
                    Calculate Dimensions
                  </button>
                </div>

                {yantras.length > 0 && (
                  <div className="grid grid-cols-1 lg:grid-cols-4 gap-6 animate-fade-in">
                    <div className="lg:col-span-1 glass-card rounded-xl p-5 shadow-xl shadow-purple-500/20">
                      <h3 className="text-xl font-bold gradient-text mb-4">Instruments</h3>
                      <div className="space-y-2">
                        {yantras.map((yantra, idx) => (
                          <button
                            key={idx}
                            onClick={() => setSelectedYantra(yantra)}
                            className={`w-full text-left px-4 py-3 rounded-lg font-medium transition-all transform hover:scale-105 ${
                              selectedYantra?.name === yantra.name
                                ? theme === 'dark'
                                  ? 'bg-gradient-to-r from-purple-600 to-pink-600 text-white shadow-lg shadow-purple-500/50'
                                  : 'bg-gradient-to-r from-orange-500 to-red-500 text-white shadow-lg shadow-orange-500/50'
                                : theme === 'dark'
                                  ? 'bg-slate-800/50 hover:bg-slate-700/50 text-gray-300 border border-purple-500/30'
                                  : 'bg-white/50 hover:bg-white/70 text-gray-800 border border-orange-400/30'
                            }`}
                          >
                            {yantra.name}
                          </button>
                        ))}
                      </div>
                    </div>

                    {selectedYantra && (
                      <div className="lg:col-span-3 space-y-6">
                        <div className="glass-card rounded-xl p-6 shadow-xl shadow-purple-500/20">
                          <h2 className="text-3xl font-bold gradient-text mb-3">{selectedYantra.name}</h2>
                          <p className={`text-lg mb-6 ${theme === 'dark' ? 'text-purple-200' : 'text-orange-800'}`}>{selectedYantra.description}</p>
                          
                          <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
                            {Object.entries(selectedYantra.dimensions).map(([key, value]) => (
                              <div key={key} className={`rounded-lg p-4 border-2 transition-all transform hover:scale-105 shadow-lg ${
                                theme === 'dark'
                                  ? 'bg-gradient-to-br from-purple-900/40 to-indigo-900/40 border-purple-500/30 hover:border-purple-400/50'
                                  : 'bg-gradient-to-br from-orange-100 to-yellow-100 border-orange-400/30 hover:border-orange-500/50'
                              }`}>
                                <div className={`text-xs font-semibold uppercase tracking-wide mb-1 ${theme === 'dark' ? 'text-purple-300' : 'text-orange-700'}`}>{key.replace(/([A-Z])/g, ' $1').trim()}</div>
                                <div className="text-2xl font-bold bg-gradient-to-r from-yellow-400 to-orange-400 bg-clip-text text-transparent">
                                  {typeof value === 'number' ? value.toFixed(2) : value}
                                  {typeof value === 'number' && !key.includes('ngle') && !key.includes('ivision') && !key.includes('umber') ? 'm' : ''}
                                  {key.includes('ngle') ? '°' : ''}
                                </div>
                              </div>
                            ))}
                          </div>
                        </div>

                        {selectedYantra.detailedInfo && (
                          <div className="glass-card rounded-xl p-6 shadow-xl shadow-purple-500/20">
                            <h3 className="text-2xl font-bold gradient-text mb-4">Detailed Information</h3>
                            <div className="space-y-4">
                              <div>
                                <h4 className={`text-lg font-semibold mb-2 ${theme === 'dark' ? 'text-purple-300' : 'text-orange-700'}`}>Purpose</h4>
                                <p className={theme === 'dark' ? 'text-gray-300' : 'text-gray-700'}>{selectedYantra.detailedInfo.purpose}</p>
                              </div>
                              <div>
                                <h4 className={`text-lg font-semibold mb-2 ${theme === 'dark' ? 'text-purple-300' : 'text-orange-700'}`}>Construction</h4>
                                <p className={theme === 'dark' ? 'text-gray-300' : 'text-gray-700'}>{selectedYantra.detailedInfo.construction}</p>
                              </div>
                              <div>
                                <h4 className={`text-lg font-semibold mb-2 ${theme === 'dark' ? 'text-purple-300' : 'text-orange-700'}`}>Usage</h4>
                                <p className={theme === 'dark' ? 'text-gray-300' : 'text-gray-700'}>{selectedYantra.detailedInfo.usage}</p>
                              </div>
                              <div>
                                <h4 className={`text-lg font-semibold mb-2 ${theme === 'dark' ? 'text-purple-300' : 'text-orange-700'}`}>Accuracy</h4>
                                <p className={theme === 'dark' ? 'text-gray-300' : 'text-gray-700'}>{selectedYantra.detailedInfo.accuracy}</p>
                              </div>
                              <div>
                                <h4 className={`text-lg font-semibold mb-2 ${theme === 'dark' ? 'text-purple-300' : 'text-orange-700'}`}>Historical Context</h4>
                                <p className={theme === 'dark' ? 'text-gray-300' : 'text-gray-700'}>{selectedYantra.detailedInfo.historicalContext}</p>
                              </div>
                            </div>
                          </div>
                        )}

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                          <div className="glass-card rounded-xl p-5 shadow-xl shadow-purple-500/20">
                            <h3 className="text-xl font-bold gradient-text mb-4 flex items-center gap-2">
                              <Ruler size={24} className={theme === 'dark' ? 'text-purple-400' : 'text-orange-600'} />
                              2D Diagram
                            </h3>
                            <DiagramGenerator yantra={selectedYantra} theme={theme} />
                          </div>

                          <div className="glass-card rounded-xl p-5 shadow-xl shadow-purple-500/20">
                            <h3 className="text-xl font-bold gradient-text mb-4 flex items-center gap-2">
                              <Box size={24} className={theme === 'dark' ? 'text-purple-400' : 'text-orange-600'} />
                              3D Model
                            </h3>
                            <p className={`text-sm mb-3 italic ${theme === 'dark' ? 'text-purple-300' : 'text-orange-700'}`}>🖱️ Drag to rotate • 🔍 Scroll to zoom</p>
                            <Model3D yantra={selectedYantra} theme={theme} />
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
          );
        }

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<YantraApp />);
    </script>
</body>
</html>
